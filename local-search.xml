<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>NOI2023春季测试</title>
    <link href="/2023/03/22/2023NOI%E6%98%A5%E5%AD%A3%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/03/22/2023NOI%E6%98%A5%E5%AD%A3%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="NOI2023春季测试"><a href="#NOI2023春季测试" class="headerlink" title="NOI2023春季测试"></a>NOI2023春季测试</h1><h2 id="P9118-幂次"><a href="#P9118-幂次" class="headerlink" title="P9118 幂次"></a>P9118 幂次</h2><p><a href="https://www.luogu.com.cn/problem/P9118">题目传送门</a></p><p><a href="https://www.luogu.com.cn/paste/j0ftu3km">10pts代码</a></p><p>题解：</p><p><a href="https://www.luogu.com.cn/blog/zqh158233/solution-p9118#">(摘自洛谷大佬永远的幻想乡)</a></p><p>我们令 $f(i)$ 表示 $x=a^i(x\le N,x_i\not=x_j)$ 的个数。 </p><p>令 $g(i)$ 表示 $x=a^i(x\le N)$ 的个数。 很容易得到 $g(i)=f(i)+f(2i)+\cdots+f(ki),(ki\le 100)$。 </p><p>易知 $g(i)=\sqrt[i]n$。 </p><p>所以 $f(i)=g(i)-f(2i)-f(3i)-\cdots-f(ki)$。 </p><p>从前往后推，容斥即可，时间复杂度 $O(k\log k)$。 </p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> ll Maxn=<span class="hljs-number">110</span>;<br>ll f[Maxn],n,k,ans=<span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">100</span>;i&gt;=k;i--)&#123;<br>        f[i]=pow&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>&gt;(n,<span class="hljs-number">1.0</span>/i)<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(ll j=i&lt;&lt;<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">100</span>;j+=i) f[i]-=f[j];<br>        ans+=f[i];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>补充知识：<a href="https://blog.csdn.net/u011815404/article/details/81633866/">组合数学 —— 容斥定理</a></p><h2 id="P9117-涂色游戏"><a href="#P9117-涂色游戏" class="headerlink" title="P9117 涂色游戏"></a>P9117 涂色游戏</h2><p><a href="https://www.luogu.com.cn/problem/P9117">题目传送门</a></p><p><a href="https://www.luogu.com.cn/paste/s0btf3l3">10pts代码</a></p><p>题解：</p><p><a href="https://www.luogu.com.cn/blog/andyli/solution-p9117">(摘自洛谷大佬andyli)</a></p><p>对于每行和每列，分别记录这一整行/列上一次被修改为的值以及修改的时间。最终对于每个数，它对应行和对应列中修改时间靠后的那一行/列的值便是他的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">multipleTests</span>([&amp;]() &#123;<br>        <span class="hljs-built_in">dR</span>(<span class="hljs-keyword">int</span>, n, m, q);<br>        std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">a</span>(n), <span class="hljs-built_in">b</span>(m), <span class="hljs-built_in">t0</span>(n), <span class="hljs-built_in">t1</span>(m);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) &#123;<br>            <span class="hljs-built_in">dR</span>(<span class="hljs-keyword">int</span>, op, x, c), x--;<br>            <span class="hljs-keyword">if</span> (op == <span class="hljs-number">0</span>)<br>                a[x] = c, t0[x] = i; <span class="hljs-comment">// 修改这行的值及时间戳</span><br>            <span class="hljs-keyword">else</span><br>                b[x] = c, t1[x] = i; <span class="hljs-comment">// 修改这列的值及时间戳</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, <span class="hljs-built_in">writeln</span>())<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>                <span class="hljs-keyword">if</span> (t0[i] &gt; t1[j]) <span class="hljs-comment">// 比较修改时间</span><br>                    io.<span class="hljs-built_in">write</span>(a[i], <span class="hljs-string">&#x27; &#x27;</span>);<br>                <span class="hljs-keyword">else</span><br>                    io.<span class="hljs-built_in">write</span>(b[j], <span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>你也可以只用两个 <code>unsigned long long</code> 数组，前半部分存时间，后半部分存值，输出时强制转换成 <code>unsigned </code>可以取值，比较大小可以直接比较。</p><p>加上一些快读和快写优化跑到了最优解（官方数据 207ms）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">dR</span>(<span class="hljs-keyword">unsigned</span>, t);<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">dR</span>(<span class="hljs-keyword">unsigned</span>, n, m, q);<br>        <span class="hljs-function">std::vector&lt;u64&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) &#123;<br>            <span class="hljs-built_in">dR</span>(<span class="hljs-keyword">unsigned</span>, op, x, c), x--;<br>            <span class="hljs-keyword">if</span> (op == <span class="hljs-number">0</span>)<br>                a[x] = (<span class="hljs-built_in">u64</span>(i) &lt;&lt; <span class="hljs-number">32</span>) + c;<br>            <span class="hljs-keyword">else</span><br>                b[x] = (<span class="hljs-built_in">u64</span>(i) &lt;&lt; <span class="hljs-number">32</span>) + c;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, <span class="hljs-built_in">writeln</span>())<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>                <span class="hljs-keyword">if</span> (a[i] &gt; b[j])<br>                    io.<span class="hljs-built_in">write</span>(<span class="hljs-built_in"><span class="hljs-keyword">unsigned</span></span>(a[i]), <span class="hljs-string">&#x27; &#x27;</span>);<br>                <span class="hljs-keyword">else</span><br>                    io.<span class="hljs-built_in">write</span>(<span class="hljs-built_in"><span class="hljs-keyword">unsigned</span></span>(b[j]), <span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度优先搜索模板</title>
    <link href="/2023/03/04/DFS/"/>
    <url>/2023/03/04/DFS/</url>
    
    <content type="html"><![CDATA[<p>DFS 最显著的特征在于其 <strong>递归调用自身</strong>。同时与 BFS 类似，DFS 会对其访问过的点打上访问标记，在遍历图时跳过已打过标记的点，以确保 <strong>每个点仅访问一次</strong>。符合以上两条规则的函数，便是广义上的 DFS。</p><p>具体地说，DFS 大致结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dep,<span class="hljs-string">&#x27;其他参数&#x27;</span>)</span></span><br><span class="hljs-function"> </span>&#123;<br>   <span class="hljs-string">&#x27;自定义参数&#x27;</span>;<br>   <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;无法再更新的状态&#x27;</span>)<span class="hljs-comment">//对目标状态的判断</span><br>   &#123;<br>     <span class="hljs-string">&#x27;输出解或计数作评价处理&#x27;</span> ; <br>   &#125; <br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;剪枝条件满足 当前状态无用&#x27;</span>)<br>   &#123;<br>     <span class="hljs-keyword">return</span>;<br>   &#125; <br>   <span class="hljs-keyword">else</span><br>   &#123;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-string">&#x27;状态的拓展可能性&#x27;</span>;i++)<br>     &#123;<br>       <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;第i种拓展可行&#x27;</span>)<br>       &#123;<br>         <span class="hljs-string">&#x27;标记&#x27;</span> ;<br>         <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;其他参数&#x27;</span>) ; <span class="hljs-comment">//更新状态</span><br>         <span class="hljs-string">&#x27;清除标记&#x27;</span> <br>       &#125;<br>     &#125;<br>   &#125;<br> &#125; <br></code></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/problem/P1706">Luogu P1706 全排列问题</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">50</span>];  <span class="hljs-comment">// 访问标记数组</span><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">50</span>];     <span class="hljs-comment">// 排列数组，按顺序储存当前搜索结果</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> step)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (step == n + <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 边界</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>      cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">5</span>) &lt;&lt; a[i];  <span class="hljs-comment">// 保留5个场宽</span><br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (vis[i] == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 判断数字i是否在正在进行的全排列中</span><br>      vis[i] = <span class="hljs-number">1</span>;<br>      a[step] = i;<br>      <span class="hljs-built_in">dfs</span>(step + <span class="hljs-number">1</span>);<br>      vis[i] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 这一步不使用该数 置0后允许下一步使用</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n;<br>  <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模板</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集模板</title>
    <link href="/2023/03/03/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/03/03/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中</p><h1 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h1><p><a href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集</a></p><p><a href="https://www.luogu.com.cn/user/35891">（摘自洛谷大佬huangzirui）</a></p><p>关于并查集和路径压缩：</p><p>现在我们假定 <code>f[i]</code> 表示第 i 个人的老大是谁。</p><p>现在我们有甲，乙，丙三个人（分别用 a, b, c 表示）</p><p>假设甲和乙打架了，甲做了丙的小弟。则有 <code>f[a]=b</code>，</p><p>后来甲打赢了丙</p><p>那么丙就是甲的小弟了。有 <code>f[c]=a</code>，</p><p>但是如果我们这样表示，丙不能直接知道甲，容易自己人打自己人</p><p>所以，我们必须直接让丙的大哥变成最大的老大。</p><p>定义函数 <code>find</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[k]==k)<span class="hljs-keyword">return</span> k;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(f[k]);<br>&#125;<span class="hljs-comment">//find 函数可以直接找到最大的老大</span><br><br>f[c]=<span class="hljs-built_in">find</span>(a);<br><span class="hljs-comment">//丙的老大是甲</span><br></code></pre></td></tr></table></figure><p>这时，因为我们要路过他所有的上级，我们也可以顺便使途中经过的人的大哥也变成老大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//路径压缩</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[k]==k)<span class="hljs-keyword">return</span> k;<br>    <span class="hljs-keyword">return</span> f[k]=<span class="hljs-built_in">find</span>(f[k]);<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    即：</span><br><span class="hljs-comment">    f[k]=find(f[k]);</span><br><span class="hljs-comment">        return f[k];</span><br><span class="hljs-comment">    */</span><br>&#125;<br><br>f[c]=<span class="hljs-built_in">find</span>(a);<br></code></pre></td></tr></table></figure><p>简直是太巧妙了！</p><p>而判定两个人的老大是否相等，只需</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b))<br></code></pre></td></tr></table></figure><p>就好了。</p><p>一些设定：</p><ul><li>一个人不能有两个老大。</li><li>当已经有老大的人臣服时，老大也将成为胜利的人的小弟。</li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> i,j,k,n,m,s,ans,f[<span class="hljs-number">10010</span>],p1,p2,p3;<br><span class="hljs-comment">//f[i]表示i的集合名</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br><span class="hljs-comment">//路径压缩</span><br>    <span class="hljs-keyword">if</span>(f[k]==k)<span class="hljs-keyword">return</span> k;<br>    <span class="hljs-keyword">return</span> f[k]=<span class="hljs-built_in">find</span>(f[k]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        f[i]=i;<span class="hljs-comment">//初始化i的老大为自己</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;p1&gt;&gt;p2&gt;&gt;p3;<br>        <span class="hljs-keyword">if</span>(p1==<span class="hljs-number">1</span>)<br>            f[<span class="hljs-built_in">find</span>(p2)]=<span class="hljs-built_in">find</span>(p3);<br>            <span class="hljs-comment">//p3打赢了p2</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(p2)==<span class="hljs-built_in">find</span>(p3))<br>            <span class="hljs-comment">//是否是一伙的</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Y\n&quot;</span>);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;N\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模板</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归算法</title>
    <link href="/2022/07/03/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/03/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p class="note note-primary">本文将简单介绍递归算法及其应用</p><h2 id="一个故事"><a href="#一个故事" class="headerlink" title="一个故事"></a>一个故事</h2><p>​      <img src="https://pic.imgdb.cn/item/62c1a6bd5be16ec74a36c0b5.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>递归是一种思想。<br>递归是一种思维方式。<br>递归是一种算法。</p><h2 id="递归算法的实现"><a href="#递归算法的实现" class="headerlink" title="递归算法的实现"></a>递归算法的实现</h2><p>递归算法，通常是借助于递归函数来实现的。<br>一个函数直接或间接调用自己——递归函数</p><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>计算n的阶乘：n!<br>n!=1<em>2</em>…*(n-1)*n<br>规定0!=1<br>（数据范围0&lt;=n&lt;=20）<br>样例输入：5<br>样例输出：120</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析<img src="https://pic.imgdb.cn/item/62c1a8085be16ec74a3895ce.png"></h4><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LL long long</span><br><span class="hljs-function">LL <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> n*<span class="hljs-built_in">f</span>(n<span class="hljs-number">-1</span>);<br>       <span class="hljs-comment">// return !n ? 1 : n*f(n-1);</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n;<br>cin&gt;&gt;n;<br>cout&lt;&lt;<span class="hljs-built_in">f</span>(n)&lt;&lt;endl; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="斐波那契数列的递归实现"><a href="#斐波那契数列的递归实现" class="headerlink" title="斐波那契数列的递归实现"></a>斐波那契数列的递归实现</h3><p><img src="https://pic.imgdb.cn/item/62c1ada15be16ec74a4028dd.png"></p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>输入x和n的值，求x^n。<br>样例输入：2 3<br>样例输出：8</p><p>请写出求x^n的递归函数</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><h3 id="递归的优缺点"><a href="#递归的优缺点" class="headerlink" title="递归的优缺点"></a>递归的优缺点</h3><h4 id="解决效率低的方法："><a href="#解决效率低的方法：" class="headerlink" title="解决效率低的方法："></a>解决效率低的方法：</h4><p>1、记忆化<br>2、转递推</p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>递归过程必须解决两个问题</p><p>跳进递归——递归计算的公式<br>跳出递归——递归结束的条件</p><h2 id="递归过程的算法描述框架："><a href="#递归过程的算法描述框架：" class="headerlink" title="递归过程的算法描述框架："></a>递归过程的算法描述框架：</h2><p>if (到达递归出口)<br>        返回递归出口处的函数值;<br>else<br>        递归计算公式并返回结果;</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>递归有两个过程：<br>1、把大问题一步一步往小问题分解；<br>2、从最小的问题开始，根据递推关系一步一步得到新的解决方案，最后得到所得解。<br>所以，递归的本质其实还是递推关系，没有这个递推关系，就无法产生递归定义的合理性，合理性就是要求能够调用函数的本身，函数可以永远适用，这里面的思想就是使用一种相同的方法来描绘整个世界。只不过，递归还想强调一种分治的思想，这种思想在解决复杂问题中有非常重要的应用。</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
