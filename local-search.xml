<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RunningCheese Chrome 103.0稳定版</title>
    <link href="/2022/07/09/Chrome/"/>
    <url>/2022/07/09/Chrome/</url>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><a href="https://tva1.sinaimg.cn/large/008i3skNgy1gptgkupe4oj30zk059whx.jpg"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gptgkupe4oj30zk059whx.jpg" alt="RunningCheese Chrome 103.0 稳定版"></a></p><p>RunningCheese Chrome 是一款提高 Chrome 易用性的定制版浏览器，可以为你在工作学习上提供极大的便利。</p><h2 id="浏览器特色"><a href="#浏览器特色" class="headerlink" title="浏览器特色"></a>浏览器特色</h2><p><a href="https://tva1.sinaimg.cn/large/002eZq73gy1gvmxwfuvo2j61400p0hdt02.jpg"><img src="https://tva1.sinaimg.cn/large/002eZq73gy1gvmxwfuvo2j61400p0hdt02.jpg" alt="RunningCheese Chrome 103.0 稳定版"></a></p><p><strong>主要特色：</strong></p><p>1、绿色便携，下载解压即可使用，内核可随 Chrome 官方发布的版本更新。<br>2、操作逻辑和习惯来自于 <a href="https://www.runningcheese.com/v10">RunningCheese Firefox</a>，算得上无缝切换。<br>3、适配国人使用习惯，已经配置好了大多数功能，比如网盘加速、去广告、翻译、下载、代理等等。</p><p><strong>更新内容：</strong></p><p>• 此次更新：<a href="https://mp.weixin.qq.com/s/AMInzq5ZHsUBLW24aXCnJA">https://mp.weixin.qq.com/s/AMInzq5ZHsUBLW24aXCnJA</a></p><p>• 历史更新：<a href="https://mp.weixin.qq.com/s/cV4a7eL3qcNZQTRIjg97BQ">101.0</a>、<a href="https://mp.weixin.qq.com/s/rvnCwP3HBn-5mGOKOh9LHg">100.0</a></p><p>• 历史更新：<a href="https://mp.weixin.qq.com/s/9K66Hr0oTwwHOfxqLBx44Q">99.0</a>、<a href="https://mp.weixin.qq.com/s/3RNWq-IVuAWyPJ-jZt5JZA">98.0</a>、<a href="https://mp.weixin.qq.com/s/5n_t78xlsGEODYJiN47r3A">97.0</a>、<a href="https://mp.weixin.qq.com/s/k1v6N4HQJy5l_5lNRaMvLA">96.0</a>、<a href="https://mp.weixin.qq.com/s/iMV_diQNzUj3sU_nogJlOg">95.0</a>、<a href="https://mp.weixin.qq.com/s/R75akb4pFX0CGhG-BRgGmQ">94.0</a>、<a href="https://mp.weixin.qq.com/s/v4wf-MZEIpT8Bpoi16oiQw">93.0</a>、<a href="https://mp.weixin.qq.com/s/86F8AoYo1oxk4aS1TYbx9w">91.0</a>、<a href="https://mp.weixin.qq.com/s/WWwTkPLl44F8wnuipf-5QQ">90.0</a></p><p>• 历史更新：<a href="https://mp.weixin.qq.com/s/gpfV0MN_mtMJV7Eej6nv4w">89.0</a>、<a href="https://mp.weixin.qq.com/s/Tz6JmoX5I5FrgCX6F8T1Iw">88.0</a>、<a href="https://mp.weixin.qq.com/s/oqaFqigli6YeI8FiG8jxdw">87.0</a>、<a href="https://mp.weixin.qq.com/s/inNa0vz-_H1GeD4d15gAiw">85.0</a>、<a href="https://mp.weixin.qq.com/s/UpjXiqSBB8QLcX458FBYcw">84.0</a>、<a href="https://mp.weixin.qq.com/s/ZkiA-7aIf2fb7mRZx0I27A">80.0</a>、<a href="https://mp.weixin.qq.com/s/wPYw3n7msI34f9pNOkif8Q">79.0</a>、<a href="https://mp.weixin.qq.com/s/bYlpvuy5OMZmemvH-YoCMQ">78.0</a></p><p>• Mac 版本：<a href="https://www.runningcheese.com/chrome-for-mac">https://www.runningcheese.com/chrome-for-mac</a></p><p>• 使用手册：<a href="https://www.runningcheese.com/chrome-usage">https://www.runningcheese.com/chrome-usage</a></p><h2 id="浏览器下载"><a href="#浏览器下载" class="headerlink" title="浏览器下载"></a>浏览器下载</h2><p><strong>下载链接：</strong><a href="https://www.lanzoui.com/b0ufru1i">https://www.lanzoui.com/b0ufru1i</a><br>备份链接：<a href="https://www.lanzouq.com/b0ufru1i">https://www.lanzouq.com/b0ufru1i</a></p><p><strong>下载说明：</strong></p><p>1、绿色免安装，下载解压后，点击 “<strong>开始.bat</strong>“ 就会创建一个启动快捷方式。<br>2、带有 32bit 的压缩包是 32 位版，没带的是 64 位版。<br>3、下载的 7z 压缩文件建议不要删除，当 Chrome 出现问题时，可以重新解压使用。</p><p><strong>如何升级：</strong></p><p>1、登录你的 Google 帐号，书签、拓展就会自动同步了。<br>2、转移旧版配置的<strong>书签</strong>，将旧版配置文件夹下的 “\Data\Default\Bookmarks” 覆盖到新版同名文件。<br>3、如果书签图标是空白的，将旧版配置文件夹下的 “\Data\Default\Favicons” 覆盖到新版同名文件。<br>4、转移旧版配置的<strong>历史记录</strong>，将旧版配置文件夹下的 “\Data\Default\History” 覆盖到新版同名文件。<br>5、转移旧版配置的<strong>搜索引擎</strong>，将旧版配置文件夹下的 “\Data\Default\Web Data” 覆盖到新版同名文件。<br>6、更多说明参考这里：<a href="https://www.runningcheese.com/trouble-shooting">https://www.runningcheese.com/trouble-shooting</a></p><p><strong>内核更新</strong></p><p>因便携化需求，定制版 Chrome 浏览器的内核已经移去更新模块，如需升级内核，重新下载压缩包，替换原来的 App 文件夹就可以了。</p><div class="note note-success">            <p>注：本文由 作者：<a href="https://www.runningcheese.com/author/1">奔跑中的奶酪</a> 发表，其版权均为作者所有，如需转载，请注明作者名字以及文章来源。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>软件分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>干货</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条件运算符</title>
    <link href="/2022/07/04/%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2022/07/04/%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>对于有些选择分支结构,可以使用简单的条件运算符来代替. 如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(a&lt;b)<br>min=a;<br><span class="hljs-keyword">else</span><br>min=b;<br></code></pre></td></tr></table></figure><p>可以用下面的条件运算符来处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">min=(a&lt;b)?a:b;<br></code></pre></td></tr></table></figure><p>其中**”(a&lt;b)?a:b”<strong>是一个</strong>“条件表达式”**,它是这样执行的:　如果a&lt;b为真,则表达式取a值,否则取b值.</p><div class="note note-success">            <p>条件运算符由两个符号组成**”?”和”:”<strong>, 要求有</strong>3个<strong>操作对象,所以也叫它</strong>三目运算符**,它是C语言中唯一的<strong>三目运算符</strong>.</p><p>它的一般形式为:</p><p><strong>表达式1?表达式2:表达式3;</strong></p>          </div>]]></content>
    
    
    <categories>
      
      <category>语言编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息奥赛-递归</title>
    <link href="/2022/07/03/%E4%BF%A1%E6%81%AF%E5%A5%A5%E8%B5%9B-%E9%80%92%E5%BD%92/"/>
    <url>/2022/07/03/%E4%BF%A1%E6%81%AF%E5%A5%A5%E8%B5%9B-%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p class="note note-primary">本文将简单介绍递归算法及其应用</p><h2 id="一个故事"><a href="#一个故事" class="headerlink" title="一个故事"></a>一个故事</h2><p> <img src="https://pic.imgdb.cn/item/62c1a6bd5be16ec74a36c0b5.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>递归是一种思想。<br>递归是一种思维方式。<br>递归是一种算法。</p><h2 id="递归算法的实现"><a href="#递归算法的实现" class="headerlink" title="递归算法的实现"></a>递归算法的实现</h2><p>递归算法，通常是借助于递归函数来实现的。<br>一个函数直接或间接调用自己——递归函数</p><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>计算n的阶乘：n!<br>n!=1<em>2</em>…*(n-1)*n<br>规定0!=1<br>（数据范围0&lt;=n&lt;=20）<br>样例输入：5<br>样例输出：120</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析<img src="https://pic.imgdb.cn/item/62c1a8085be16ec74a3895ce.png"></h4><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LL long long</span><br><span class="hljs-function">LL <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> n*<span class="hljs-built_in">f</span>(n<span class="hljs-number">-1</span>);<br>       <span class="hljs-comment">// return !n ? 1 : n*f(n-1);</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n;<br>cin&gt;&gt;n;<br>cout&lt;&lt;<span class="hljs-built_in">f</span>(n)&lt;&lt;endl; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="斐波那契数列的递归实现"><a href="#斐波那契数列的递归实现" class="headerlink" title="斐波那契数列的递归实现"></a>斐波那契数列的递归实现</h3><p><img src="https://pic.imgdb.cn/item/62c1ada15be16ec74a4028dd.png"></p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>输入x和n的值，求x^n。<br>样例输入：2 3<br>样例输出：8</p><p>请写出求x^n的递归函数</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><h3 id="递归的优缺点"><a href="#递归的优缺点" class="headerlink" title="递归的优缺点"></a>递归的优缺点</h3><h4 id="解决效率低的方法："><a href="#解决效率低的方法：" class="headerlink" title="解决效率低的方法："></a>解决效率低的方法：</h4><p>1、记忆化<br>2、转递推</p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>递归过程必须解决两个问题</p><p>跳进递归——递归计算的公式<br>跳出递归——递归结束的条件</p><h2 id="递归过程的算法描述框架："><a href="#递归过程的算法描述框架：" class="headerlink" title="递归过程的算法描述框架："></a>递归过程的算法描述框架：</h2><p>if (到达递归出口)<br>        返回递归出口处的函数值;<br>else<br>        递归计算公式并返回结果;</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>递归有两个过程：<br>1、把大问题一步一步往小问题分解；<br>2、从最小的问题开始，根据递推关系一步一步得到新的解决方案，最后得到所得解。<br>所以，递归的本质其实还是递推关系，没有这个递推关系，就无法产生递归定义的合理性，合理性就是要求能够调用函数的本身，函数可以永远适用，这里面的思想就是使用一种相同的方法来描绘整个世界。只不过，递归还想强调一种分治的思想，这种思想在解决复杂问题中有非常重要的应用。</p>]]></content>
    
    
    <categories>
      
      <category>语言编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息奥赛</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EasyX入门篇</title>
    <link href="/2021/12/19/EasyX%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <url>/2021/12/19/EasyX%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="EasyX入门篇"><a href="#EasyX入门篇" class="headerlink" title="EasyX入门篇"></a>EasyX入门篇</h1><p>EasyX<br>在学习C语言时，很多同学抱怨说C只能写最简单的Demo程序，通过printf在屏幕上打印字符来验证代码。这样的编程很枯燥，一点没觉得自己在设计软件。</p><p>EasyX是针对C++的第三方图形库，通过它我们能够在屏幕上绘制出自己喜欢的各种颜色的图形。有了它，自己编写好玩的小游戏不是梦哦。</p><p>使用EasyX有下面几点要求：</p><p>只能在Windows下使用<br>建议使用Visual Studio作为IDE<br>必须写C++代码（文件后缀名为cpp）</p><h2 id="EasyX安装"><a href="#EasyX安装" class="headerlink" title="EasyX安装"></a>EasyX安装</h2><h4 id="下载路径"><a href="#下载路径" class="headerlink" title="下载路径"></a>下载路径</h4><p><a href="https://easyx.cn/downloads/">download</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>解压下载目录 EasyX_20151015(beta).zip 如下：</p><p>双击 setup.hta 文件</p><p>找到需要的VS版本点击安装即可。</p><p>PS：在解压缩的文件中，有个EasyX_help.chm文件，它是EasyX的文档，所有API的介绍都在里面。</p><p>作为一个软件开发人员，阅读文档是最基本的技能，希望大家从现在开始培养自己这方面的能力。如果你通读了这个文档之后，相信你完全能够自己完成在屏幕上画出自己想要的图案。</p><h2 id="EasyX基本API"><a href="#EasyX基本API" class="headerlink" title="EasyX基本API"></a>EasyX基本API</h2><p>在EasyX的文档中，有一节是“超简单的使用预览”，里面有这样一段代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">initgraph</span>(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>);   <span class="hljs-comment">// 创建图形界面</span><br>    <span class="hljs-built_in">circle</span>(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">// 画圆，圆心(200, 200)，半径 100</span><br>    <span class="hljs-built_in">getch</span>();               <span class="hljs-comment">// 按任意键继续</span><br>    <span class="hljs-built_in">closegraph</span>();          <span class="hljs-comment">// 关闭图形界面</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的执行结果如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDU5MDItZGZmZDJjZjQ2Mzc3MjU3Ny5wbmc?x-oss-process=image/format,png"></p><p>语法</p><ol><li><h4 id="画布的创建和销毁"><a href="#画布的创建和销毁" class="headerlink" title="画布的创建和销毁"></a>画布的创建和销毁</h4></li></ol><p>  main函数中，第一行和最后一行代码是创建和删除图形界面，这个图形界面常常被叫做“画布”。</p><p>initgraph()<br>创建画布时，需要输入目标窗口的长宽值。</p><p>closegraph()<br>和C语言中一样，C++也强调代码的对称性，申请资源和释放资源的代码总是成对出现的。</p><ol start="2"><li><h4 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h4></li></ol><p>  在 EasyX 中，坐标分为：逻辑坐标和物理坐标。</p><p>我们这里只介绍逻辑坐标。</p><p>逻辑坐标是在程序中用于绘图的坐标体系。</p><p>坐标默认的原点在屏幕的左上角，X 轴向右为正，Y 轴向下为正，度量单位是象素。</p><p>坐标的原点，方向和单位都可以通过特定函数修改。我们一般只采用默认设置。</p><ol start="3"><li><h4 id="圆形绘制"><a href="#圆形绘制" class="headerlink" title="圆形绘制"></a>圆形绘制</h4></li></ol><h4 id="circle这个函数用于画圆。"><a href="#circle这个函数用于画圆。" class="headerlink" title="circle这个函数用于画圆。"></a>circle这个函数用于画圆。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">circle</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> x,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> y,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> radius</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>参数：<br>x<br>圆的圆心 x 坐标。<br>y<br>圆的圆心 y 坐标。<br>radius<br>圆的半径。<br>Demo程序中就是用这个函数绘制了一个圆心为（200, 200），半径为100的圆形。</p><ol start="4"><li><h4 id="直线绘制"><a href="#直线绘制" class="headerlink" title="直线绘制"></a>直线绘制</h4></li></ol><p>  这个函数用于画线。还可以用 linerel 和 lineto 画线。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">line</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> x1,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> y1,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> x2,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> y2</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>参数<br>x1<br>线的起始点的 x 坐标。</p><p>y1<br>线的起始点的 y 坐标。</p><p>x2<br>线的终止点的 x 坐标。</p><p>y2<br>线的终止点的 y 坐标。</p><ol start="5"><li><h4 id="矩形绘制"><a href="#矩形绘制" class="headerlink" title="矩形绘制"></a>矩形绘制</h4></li></ol><p>  这个函数用于画空心矩形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rectangle</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> left,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> top,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> right,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> bottom</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>参数<br>left<br>矩形左部 x 坐标。</p><p>top<br>矩形上部 y 坐标。</p><p>right<br>矩形右部 x 坐标。</p><p>bottom<br>矩形下部 y 坐标。</p><ol start="6"><li><h4 id="椭圆绘制"><a href="#椭圆绘制" class="headerlink" title="椭圆绘制"></a>椭圆绘制</h4></li></ol><p>  这个函数用于画椭圆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ellipse</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> left,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> top,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> right,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> bottom</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>参数<br>left<br>椭圆外切矩形的左上角 x 坐标。</p><p>top<br>椭圆外切矩形的左上角 y 坐标。</p><p>righ椭圆外切矩形的右下角 x 坐标。</p><p>bottom<br>椭圆外切矩形的右下角 y 坐标。</p><p>上面是几个基本图形的绘制方法，它们有个特点是画出的都是空心的图形。与之对应的是一组绘制带有填充颜色图形的接口。</p><p>fillcircle(), fillellipse(), fillrectangle()<br>它们的参数和画空心的接口完全一样，只不过使用前需要调用下面这个接口设置填充颜色。</p><p>setfillcolor()<br>下面我们来看看这些函数究竟能做什么。</p><h2 id="EasyX实战"><a href="#EasyX实战" class="headerlink" title="EasyX实战"></a>EasyX实战</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDU5MDItZjk4NDE4NmJkNWViZDgxYi5wbmc?x-oss-process=image/format,png"></p><p>上面这幅图就是用EasyX实现的。哈哈，貌似有点丑， 不过假如你能独立写出这个功能，说明你已经基本掌握了EasyX的用法。</p><p>提供一个代码框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">initgraph</span>(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br><br>    <span class="hljs-comment">// Add your code</span><br><br>    <span class="hljs-built_in">closegraph</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><p>这里请先自己思考一下，不要急往下看。</p><p>（… 15分钟过去了 …）<br>分析<br>这幅图主要是由圆形、椭圆形、矩形和直线组成的，这几个形状的API我们都已经介绍过了。我们只要按顺序把它们画在屏幕上就好了。</p><p>代码实现<br>在C++工程的main.cpp文件中输入下面代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">initgraph</span>(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br><br>    <span class="hljs-comment">// 记录当前填充颜色</span><br>    COLORREF save_color = <span class="hljs-built_in">getfillcolor</span>();<br><br>    <span class="hljs-comment">// 绘制矩形框</span><br>    <span class="hljs-built_in">rectangle</span>(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">550</span>, <span class="hljs-number">550</span>);<br><br>    <span class="hljs-comment">// 画空心圆</span><br>    <span class="hljs-built_in">circle</span>(<span class="hljs-number">200</span>, <span class="hljs-number">150</span>, <span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">circle</span>(<span class="hljs-number">400</span>, <span class="hljs-number">150</span>, <span class="hljs-number">50</span>);<br><br>    <span class="hljs-comment">// 画空心椭圆    </span><br>    <span class="hljs-built_in">ellipse</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">500</span>, <span class="hljs-number">300</span>);<br><br>    <span class="hljs-comment">// 填充椭圆内的绿色部分</span><br>    <span class="hljs-built_in">setfillcolor</span>(GREEN);<br>    <span class="hljs-built_in">floodfill</span>(<span class="hljs-number">300</span>, <span class="hljs-number">200</span>, <span class="hljs-built_in">getlinecolor</span>());<br><br>    <span class="hljs-comment">// 填充一个白色的椭圆</span><br>    <span class="hljs-built_in">setfillcolor</span>(WHITE);<br>    <span class="hljs-built_in">fillellipse</span>(<span class="hljs-number">200</span>, <span class="hljs-number">210</span>, <span class="hljs-number">400</span>, <span class="hljs-number">290</span>);<br><br>    <span class="hljs-comment">// 填充一个绿色的矩形</span><br>    <span class="hljs-built_in">setfillcolor</span>(GREEN);<br>    <span class="hljs-built_in">fillrectangle</span>(<span class="hljs-number">150</span>, <span class="hljs-number">300</span>, <span class="hljs-number">450</span>, <span class="hljs-number">500</span>);<br><br>    <span class="hljs-comment">// 画一条直线</span><br>    <span class="hljs-built_in">line</span>(<span class="hljs-number">300</span>, <span class="hljs-number">500</span>, <span class="hljs-number">300</span>, <span class="hljs-number">550</span>);<br><br>    <span class="hljs-comment">// 按任意键继续</span><br>    <span class="hljs-built_in">getch</span>();<br><br>    <span class="hljs-comment">// 恢复填充颜色</span><br>    <span class="hljs-built_in">setfillcolor</span>(save_color);<br><br>    <span class="hljs-built_in">closegraph</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><p>好了，按一下Ctrl + F5，是不是看到效果了？</p><p>对大多数人来说，椭圆内部的不规则的绿色面积应该是最难实现的，floodfill()这个函数就是帮助我们将一个点所在的封闭范围内全部用填充颜色涂掉。除了设置点坐标之外还要输入这个封闭区域边框的颜色。</p><p>这里需要强调的是，在初始化画布之后，我们获取了当前的填充颜色，在绘制完成后又把当前填充颜色恢复到了我们程序执行之前的状态。</p><p>这个习惯非常重要，就是要让我们的程序在运行过之后，系统环境没有任何变化。否则在未来负责的工程中，很可能因为某个模块乱改系统设置产生很多不必要的bug。</p><p>好了，现在是不是比较有成就感呢？</p><p>由于EasyX的使用会贯穿于我们这个系列的项目中，因此这里就不过多介绍了，后面用到了新内容我们再讲。</p>]]></content>
    
    
    <categories>
      
      <category>语言编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EasyX</tag>
      
      <tag>C++</tag>
      
      <tag>花里胡哨</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
